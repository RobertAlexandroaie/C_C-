#include <sys/types.h>#include <sys/socket.h>#include <sys/time.h>#include <sys/wait.h>#include <netinet/in.h>#include <unistd.h>#include <errno.h>#include <stdio.h>#include <arpa/inet.h>#include <string.h>#include <stdio.h>#include <time.h>#include <signal.h>#define PORT 3334//structura pentru identificarea unei cartitypedef struct Carte{	int cost;//cate resurse consuma	int val;//cate resurse adauga}Carte;//structura pentru statutul unui jucatortypedef struct Resources{	int b[2];//building	int a[2];//attacking	int m[2];//magic		int c[2];//castle}Resources;//structura pentru identificarea unui jucatortypedef struct Player{	Resources status;//resursele	char nume[50];//numele	int hand[8];//cartile din mana	int sd;//descriptorul la care scriem/ de la care citim}Player;//structura pentru identificarea unui joctypedef struct Game{	Player *p1, *p2;//cei doi jucatori	int score1, score2;//scorurile	int deck[104];//incecsii pachetului jocului (pachetul e amestecat)	int used[104];//indecsii cartilor folosite	int card_control;//unde suntem in momentul asta in pachet	int r;//rundele ramase}Game;//pachetul completCarte pachet[104];extern int errno;int rounds;//functie pentru initializarea rundelor si a pachetuluiint init(){	FILE *fp;	int contor=0;	int contor_set=0;	int c,v;		fp=fopen("ant.cfg","r");		if(fscanf(fp,"%d",&rounds)< 0)	{		perror ("[server]Eroare la fscanf() din cfg(rounds)!!\n");		return 0;	}		for(contor=0;contor<26;contor++)	{		if(fscanf(fp,"%d",&c)< 0)		{			perror ("[server]Eroare la fscanf() din cfg(cost)!!\n");			return 0;		}				if(fscanf(fp,"%d",&v)< 0)		{			perror ("[server]Eroare la fscanf() din cfg(valoare)!!\n");			return 0;		}				for(contor_set=0;contor_set<4;contor_set++)		{			pachet[contor*4+contor_set].cost=c;			pachet[contor*4+contor_set].val=v;		}	}	return 0;}//functie pentru initializarea statutului unui jucatorvoid init_res(Player *p){	p->status.b[0]=2;	p->status.b[1]=5;		p->status.a[0]=2;	p->status.a[1]=5;		p->status.m[0]=2;	p->status.m[1]=5;		p->status.c[0]=30;	p->status.c[1]=10;}//functie pentru intitializarea cartilor din mana unui jucatorvoid init_cards(Game *g){	int card_id=0;	int card_contor=0;	int i,viz[104];	srand(time(NULL));		for(i=0;i<104;i++)	{		viz[i]=0;		g->deck[i]=0;		g->used[i]=0;	}		while(card_contor<104)	{		card_id = rand()%104;		if(viz[card_id]==0)		{			g->deck[card_contor++]=card_id;			viz[card_id]=1;		}	}		for(i=0;i<16;i++)	{		g->used[i]=1;	}		g->p1->hand[0]=g->deck[0];	g->p1->hand[1]=g->deck[2];	g->p1->hand[2]=g->deck[4];	g->p1->hand[3]=g->deck[6];	g->p1->hand[4]=g->deck[8];	g->p1->hand[5]=g->deck[10];	g->p1->hand[6]=g->deck[12];	g->p1->hand[7]=g->deck[14];		g->p2->hand[0]=g->deck[1];	g->p2->hand[1]=g->deck[3];	g->p2->hand[2]=g->deck[5];	g->p2->hand[3]=g->deck[7];	g->p2->hand[4]=g->deck[9];	g->p2->hand[5]=g->deck[11];	g->p2->hand[6]=g->deck[13];	g->p2->hand[7]=g->deck[15];		g->card_control=16;}//functie care transmite jucatorilor starea curenta a joculuiint send_info(Game *g, const int nr){		int sizeof_send=0;	Player *p1,*p2;		if(nr==1)	{		p1=g->p1;		p2=g->p2;	}	else	{		p1=g->p2;		p2=g->p1;	}		//p1->status.b	if(write(p1->sd,p1->status.b,8)<0)	{		perror("[server send_info]Eroare la write() spre p1.[p1->s.b]\n");		return 1;	}	//p1->status.a	if(write(p1->sd,p1->status.a,8)<0)	{		perror("[server send_info]Eroare la write() spre p1.[p1->s.a]\n");		return 2;	}		//p1->status.m	if(write(p1->sd,p1->status.m,8)<0)	{		perror("[server send_info]Eroare la write() spre p1.[p1->s.m]\n");		return 3;	}		//p1->status.c	if(write(p1->sd,p1->status.c,8)<0)	{		perror("[server send_info]Eroare la write() spre p1.[p1->s.c]\n");		return 4;	}		//p1->status.b	if(write(p1->sd,p2->status.b,8)<0)	{		perror("[server send_info]Eroare la write() spre p1.[p2->s.b]\n");		return 5;	}	//p1->status.a	if(write(p1->sd,p2->status.a,8)<0)	{		perror("[server send_info]Eroare la write() spre p1.[p2->s.a]\n");		return 6;	}		//p1->status.m	if(write(p1->sd,p2->status.m,8)<0)	{		perror("[server send_info]Eroare la write() spre p1.[p2->s.m]\n");		return 7;	}		//p1->status.c	if(write(p1->sd,p2->status.c,8)<0)	{		perror("[server send_info]Eroare la write() spre p1.[p2->s.c]\n");		return 8;	}		//p1 sizeof_send	sizeof_send=strlen(p1->nume);	if(write(p1->sd,&sizeof_send,4)<0)	{		perror("[server send_info]Eroare la write() spre p1.(sizeof_nume1)\n");		return 9;	}		//p1->nume	if(write(p1->sd,p1->nume,sizeof_send)<0)	{		perror("[server send_info]Eroare la write() spre p1.[p1->nume]\n");		return 10;	}				//p1 score	if(write(p1->sd,&g->score1,4)<0)	{		perror("[server send_info]Eroare la write() spre p1.[g->score1]\n");		return 11;	}		//p2 score	if(write(p1->sd,&g->score2,4)<0)	{		perror("[server send_info]Eroare la write() spre p1.[g->score2]\n");		return 12;	}		//p1->hand	if(write(p1->sd,p1->hand,32)<0)	{		perror("[server send_info]Eroare la write() spre p.[p->hand]\n");		return 13;	}		//p2 sizeof_send	sizeof_send=strlen(p2->nume);	if(write(p1->sd,&sizeof_send,4)<0)	{		perror("[server send_info]Eroare la write() spre p1.(sizeof_nume2)\n");		return 14;	}		//p2->nume	if(write(p1->sd,p2->nume,sizeof_send)<0)	{		perror("[server send_info]Eroare la write() spre p1.[p2->nume]\n");		return 15;	}		//g->r	if(write(p1->sd,&g->r,4)<0)	{		perror("[server send_info]Eroare la write() spre p1.[g->r]");		return 16;	}		return 0;}//functie care asigura valori nenegative/nenule in statusul unui jucatorvoid stabilize(Game *g){	if(g->p1->status.b[0]<1) g->p1->status.b[0]=1;	if(g->p1->status.a[0]<1) g->p1->status.a[0]=1;	if(g->p1->status.m[0]<1) g->p1->status.m[0]=1;	if(g->p1->status.c[0]<0) g->p1->status.c[0]=0;	if(g->p1->status.b[1]<0) g->p1->status.b[1]=0;	if(g->p1->status.a[1]<0) g->p1->status.a[1]=0;	if(g->p1->status.m[1]<0) g->p1->status.m[1]=0;	if(g->p1->status.b[1]<0) g->p1->status.c[1]=0;		if(g->p2->status.b[0]<1) g->p2->status.b[0]=1;	if(g->p2->status.a[0]<1) g->p2->status.a[0]=1;	if(g->p2->status.m[0]<1) g->p2->status.m[0]=1;	if(g->p2->status.c[0]<0) g->p2->status.c[0]=0;	if(g->p2->status.b[1]<0) g->p2->status.b[1]=0;	if(g->p2->status.a[1]<0) g->p2->status.a[1]=0;	if(g->p2->status.m[1]<0) g->p2->status.m[1]=0;	if(g->p2->status.b[1]<0) g->p2->status.c[1]=0;}//functie care modifica statusurile jucatorilor in functie de cartea folositavoid use_card(Game *g, const int player_nr, int card_id, int opt){	Player *p1,*p2;	int i=0;		if(player_nr==1)	{		p1=g->p1;		p2=g->p2;	}	else	{		p1=g->p2;		p2=g->p1;	}	if(opt==1)	{		if((card_id>=0&&card_id<8)||(card_id>=16&&card_id<20))		{			p1->status.c[0]+=pachet[card_id].val;			p1->status.b[1]-=pachet[card_id].cost;		}		if((card_id>=8&&card_id<16)||(card_id>=20&&card_id<24))		{			p1->status.c[1]+=pachet[card_id].val;			p1->status.b[1]-=pachet[card_id].cost;		}				if(card_id>=24&&card_id<28)		{			p1->status.c[0]+=pachet[card_id].val;			p1->status.b[1]-=pachet[card_id].cost;			p2->status.c[0]-=pachet[card_id].val;		}				if(card_id>=28&&card_id<32)		{			p1->status.b[0]+=pachet[card_id].val;			p1->status.b[1]-=pachet[card_id].cost;		}				if((card_id>=32&&card_id<36)||(card_id>=40&&card_id<56))		{			p1->status.a[1]-=pachet[card_id].cost;			p2->status.c[1]-=pachet[card_id].val;			if(p2->status.c[1]<0)			{				p2->status.c[0]+=p2->status.c[1];				p2->status.c[1]=0;			}		}				if(card_id>=36&&card_id<40)		{			p1->status.a[1]-=pachet[card_id].cost;			p2->status.c[0]-=pachet[card_id].val;		}				if(card_id>=56&&card_id<60)		{			p1->status.a[0]+=pachet[card_id].val;			p1->status.a[1]-=pachet[card_id].cost;		}				if(card_id>=60&&card_id<64)		{			p1->status.b[1]+=pachet[card_id].val;			p1->status.m[1]-=pachet[card_id].val;		}				if(card_id>=64&&card_id<68)		{			p1->status.a[1]+=pachet[card_id].val;			p1->status.m[1]-=pachet[card_id].val;		}				if(card_id>=68&&card_id<72)		{			p1->status.m[1]+=pachet[card_id].val;			p1->status.m[1]-=pachet[card_id].val;		}				if(card_id>=72&&card_id<76)		{			p2->status.b[1]-=pachet[card_id].val;			p1->status.m[1]-=pachet[card_id].val;		}				if(card_id>=76&&card_id<80)		{			p2->status.a[1]-=pachet[card_id].val;			p1->status.m[1]-=pachet[card_id].val;		}				if(card_id>=80&&card_id<84)		{			p2->status.m[1]-=pachet[card_id].val;			p1->status.m[1]-=pachet[card_id].val;		}				if(card_id>=84&&card_id<88)		{			p1->status.b[0]+=pachet[card_id].val;			p1->status.b[1]+=pachet[card_id].val;			p1->status.a[0]+=pachet[card_id].val;			p1->status.a[1]+=pachet[card_id].val;			p1->status.m[0]+=pachet[card_id].val;			p1->status.m[1]+=pachet[card_id].val;			p1->status.c[0]+=pachet[card_id].val;			p1->status.c[1]+=pachet[card_id].val;									p2->status.b[0]-=pachet[card_id].val;			p2->status.b[1]-=pachet[card_id].val;			p2->status.a[0]-=pachet[card_id].val;			p2->status.a[1]-=pachet[card_id].val;			p2->status.m[0]-=pachet[card_id].val;			p2->status.m[1]-=pachet[card_id].val;			p2->status.c[0]-=pachet[card_id].val;			p2->status.c[1]-=pachet[card_id].val;						p1->status.m[1]-=pachet[card_id].cost;		}				if(card_id>=88&&card_id<92)		{			p1->status.m[1]-=pachet[card_id].cost;			p2->status.c[1]-=pachet[card_id].val;			if(p2->status.c[1]<0)			{				p2->status.c[0]+=p2->status.c[1];				p2->status.c[1]=0;			}		}				if(card_id>=92&&card_id<96)		{			p1->status.c[0]+=pachet[card_id].val;			p1->status.m[1]-=pachet[card_id].cost;		}				if(card_id>=96&&card_id<100)		{			p1->status.b[1]+=pachet[card_id].val;			p1->status.a[1]+=pachet[card_id].val;			p1->status.m[1]+=pachet[card_id].val;						p2->status.b[1]-=pachet[card_id].val;			p2->status.a[1]-=pachet[card_id].val;			p2->status.m[1]-=pachet[card_id].val;						p1->status.m[1]-=pachet[card_id].cost;		}				if(card_id>=100&&card_id<104)		{			p1->status.m[0]+=pachet[card_id].val;			p1->status.m[1]-=pachet[card_id].cost;		}				stabilize(g);	}		g->used[card_id]=1;	for(i=0;i<8&&p1->hand[i]!=card_id;i++);	p1->hand[i]=g->deck[g->card_control++];}//functie care preia de la client cartea aleasa si optiunea (use/drop, apoi foloseste acea carte)int move(Player *p, Game *g, const int pl_nr){	//declarations	char msg_send[20];	int chosen_card=-1;	int opt=-1;		bzero(msg_send,20);	strcpy(msg_send,"Alegeti o carte.");		if(write(p->sd,msg_send,16)<0)	{		perror ("[server move] Eroare la cerere mutare.\n");		return 1;	}		if(read(p->sd,&opt,4)<0)	{		perror("[server move]Eroare la citire optiune in mutare.\n");		return 2;	}		if(read(p->sd,&chosen_card,4)<0)	{		perror ("[server move] Eroare la primire carte in mutare.\n");		return 3;	}		use_card(g,pl_nr,chosen_card,opt);	return 0;}void strat(Player *p, Game *g, const int pl_nr){	int i=0;	int opt=0;	int card_id=0;	for(i=0;i<8;i++)	{		if((p->hand[i]<32&&pachet[p->hand[i]].cost<p->status.b[1])		||(p->hand[i]>=32&&p->hand[i]<60&&pachet[p->hand[i]].cost<p->status.a[1])		||(p->hand[i]>=60&&p->hand[i]<104&&pachet[p->hand[i]].cost<p->status.m[1]))		{opt=1; card_id=p->hand[i]; break;}				if(i==7)		{opt=2; card_id=p->hand[i];}	}	use_card(g,pl_nr,card_id,opt);}void get_sal(Player *p){	p->status.b[1]+=p->status.b[0];	p->status.a[1]+=p->status.a[0];	p->status.m[1]+=p->status.m[0];}//functie care lanseaza jocul dintre doi jucatori conectatiint play(Player *p1, Player *p2){	Game g;		//initializam cei doi jucatori	init_res(p1);	init_res(p2);		g.r=rounds;	g.p1=p1;	g.p2=p2;	g.score1=0;	g.score2=0;		init_cards(&g);		send_info(&g,1);	send_info(&g,2);		while(g.r)	{		get_sal(p1);		send_info(&g,1);		if(move(p1,&g,1)!=0)		{			strat(p1,&g,1);		}		send_info(&g,1);				if(p1->status.c[0]>99||p2->status.c[0]<1)		{			g.score1++;			g.r--;			init_res(p1);			init_res(p2);			init_cards(&g);			continue;		}		get_sal(p2);		send_info(&g,2);		if(move(p2,&g,2)!=0)		{			strat(p2,&g,1);		}		send_info(&g,2);		if(p1->status.c[0]<1||p2->status.c[0]>99)		{			g.score2++;			g.r--;			init_res(p1);			init_res(p2);			init_cards(&g);			continue;		}	}	return 0;}char * conv_addr (struct sockaddr_in addstatuss){	static char str[25];	char port[7];	strcpy (str, inet_ntoa (addstatuss.sin_addr));	bzero (port, 7);	sprintf (port, ":%d", ntohs (addstatuss.sin_port));		strcat (str, port);	return (str);}void sighanler(int sig){	while(waitpid(-1,NULL,WNOHANG)>0);}int main (){	struct sockaddr_in socket_server;	struct sockaddr_in socket_client1;	struct sockaddr_in socket_client2;		int socket_descriptor_server, socket_descriptor_client1, socket_descriptor_client2;	int optval=1; 	int sockaddr_in_len;		int nfds;	struct timeval tv;		int pid;		char msg_send_p1[100];	char msg_send_p2[100];		char msg_rec_p1[50];	char msg_rec_p2[50];		int sizeof_buffer=0;	int sizeof_send=0;		Player pl1,pl2;		init();		if ((socket_descriptor_server = socket (AF_INET, SOCK_STREAM, 0)) == -1)	{		perror ("[server] Eroare la socket().\n");		return errno;	}	setsockopt(socket_descriptor_server, SOL_SOCKET, SO_REUSEADDR,&optval,sizeof(optval));		if( signal(SIGCHLD,sighanler) < 0 )	{		perror("[server] eroare register signal\n");		return errno;	}		bzero (&socket_server, sizeof (socket_server));	socket_server.sin_family = AF_INET;	socket_server.sin_addr.s_addr = htonl (INADDR_ANY);	socket_server.sin_port = htons (PORT);	if (bind (socket_descriptor_server, (struct sockaddr *) &socket_server, sizeof (struct sockaddr)) == -1)	{		perror ("[server] Eroare la bind().\n");		return errno;	}	if (listen (socket_descriptor_server, 5) == -1)	{		perror ("[server] Eroare la listen().\n");		return errno;	}		printf ("[server] Asteptam la portul %d...\n", PORT);	fflush (stdout);	while (1)	{		bzero(msg_send_p1,100);		bzero(msg_rec_p1,50);		bzero(msg_send_p2,100);		bzero(msg_rec_p2,50);				sockaddr_in_len = sizeof (socket_client1);		bzero (&socket_client1, sizeof (socket_client1));		socket_descriptor_client1 = accept (socket_descriptor_server, (struct sockaddr *) &socket_client1, &sockaddr_in_len);		if (socket_descriptor_client1 < 0)		{			perror ("[server] Eroare la accept().\n");			continue;		}				if(read(socket_descriptor_client1, msg_rec_p1, 11) < 0)		{			perror("Eroare la read() de la player1.(autentificare)\n");			return 0;					}				strcpy(msg_send_p1,"OK");				if(strcmp(msg_rec_p1,"opensessamy")!=0)		{			printf("[server]Client neautorizat!Inchiem conexiunea cu el.\n");			fflush (stdout);			close (socket_descriptor_client1);		}		else		{			printf("[server]Client valid.\n");			fflush(stdout);			if(write(socket_descriptor_client1, msg_send_p1, 2)<=0)			{				perror("Eroare la write() catre player1.(autentificare)\n");				return 0;			}		}				printf("[server] S-a conectat clientul cu descriptorul %d, de la adresa %s.\n",socket_descriptor_client1, conv_addr (socket_client1));		fflush (stdout);				sizeof_buffer=0;		if(read (socket_descriptor_client1, &sizeof_buffer, 4) < 0)		{			perror ("Eroare la read() de la player1(sizeof_buffer).\n");			return 0;		}				bzero(msg_rec_p1,50);		if(read (socket_descriptor_client1, msg_rec_p1, sizeof_buffer) < 0)		{			perror ("Eroare la read() de la player1[msg_rec_p1].\n");			return 0;		}				bzero(msg_send_p1,100);		strcpy(pl1.nume,msg_rec_p1);		strcpy(msg_send_p1,msg_rec_p1);		strcat(msg_send_p1,", esti jucatorul #1.");		sizeof_send=strlen(msg_send_p1);						if (write (socket_descriptor_client1, &sizeof_send, 4) < 0)		{			perror ("[server] Eroare la write() catre player1(sizeof_send).\n");			return 0;		}				if (write (socket_descriptor_client1, msg_send_p1, sizeof_send) < 0)		{			perror ("[server] Eroare la write() catre player1[msg_send_p1].\n");			return 0;		}		//--------------------------------------------------------------------------------				sockaddr_in_len = sizeof (socket_client2);		bzero (&socket_client2, sizeof (socket_client2));		socket_descriptor_client2 = accept (socket_descriptor_server, (struct sockaddr *) &socket_client2, &sockaddr_in_len);		if (socket_descriptor_client2 < 0)		{			perror ("[server] Eroare la accept().\n");			continue;		}		if(read(socket_descriptor_client2, msg_rec_p2, 11) < 0)		{			perror("Eroare la read() de la player1.(autentificare)\n");			return 0;		}				strcpy(msg_send_p2,"OK");				if(strcmp(msg_rec_p2,"opensessamy")!=0)		{			printf("[server]Client neautorizat!Inchiem conexiunea cu el.\n");			fflush (stdout);			close (socket_descriptor_client2);		}		else		{			printf("[server]Client valid.\n");			fflush(stdout);			if(write(socket_descriptor_client2, msg_send_p2, 2)<=0)			{				perror("Eroare la write() catre player2.(autentificare)\n");				return 0;			}		}		printf("[server] S-a conectat clientul cu descriptorul %d, de la adresasa %s.\n",socket_descriptor_client2, conv_addr (socket_client2));		fflush (stdout);				sizeof_buffer=0;		if(read (socket_descriptor_client2, &sizeof_buffer, 4) < 0)		{			perror ("Eroare la read() de la player2(sizeof_buffer).\n");			return 0;		}				bzero(msg_rec_p2,50);		if(read (socket_descriptor_client2, msg_rec_p2, sizeof_buffer) < 0)		{			perror ("Eroare la read() de la player1.\n");			return 0;		}						bzero(msg_send_p2,100);		strcpy(pl2.nume,msg_rec_p2);		strcpy(msg_send_p2,msg_rec_p2);		strcat(msg_send_p2,", esti jucatorul #2.");		sizeof_send=strlen(msg_send_p2);				if (write (socket_descriptor_client2, &sizeof_send, 4) < 0)		{			perror ("[server] Eroare la write() catre player2(sizeof_send).\n");			return 0;		}				if (write (socket_descriptor_client2, msg_send_p2, sizeof_send) < 0)		{			perror ("[server] Eroare la write() catre player2[msg_send_p2].\n");			return 0;		}						pl1.sd=socket_descriptor_client1;		pl2.sd=socket_descriptor_client2;				if((pid=fork())<0)		{			printf("[server]Eroare la fork()\n");			return 1;		}				if(pid==0)		{			printf("New game!\n");			fflush(stdout);						if(play(&pl1,&pl2)==0)			{				printf("Game over!\n");				fflush(stdout);								printf ("[server] S-a deconectat clientul cu descriptorul %d.\n",socket_descriptor_client1);				fflush (stdout);				close (socket_descriptor_client1);												printf ("[server] S-a deconectat clientul cu descriptorul %d.\n",socket_descriptor_client2);				fflush (stdout);				close (socket_descriptor_client2);			}		}		else//tata		{			close(socket_descriptor_client1);			close(socket_descriptor_client2);		}	}//while}